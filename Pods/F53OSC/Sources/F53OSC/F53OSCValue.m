//
//  F53OSCValue.m
//
//  Created by Brent Lord on 2/19/20.
//
//  Copyright (c) 2020 Figure 53 LLC, https://figure53.com
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
//

#if !__has_feature(objc_arc)
#error This file must be compiled with ARC. Use -fobjc-arc flag (or convert project to ARC).
#endif

#import "F53OSCValue.h"


NS_ASSUME_NONNULL_BEGIN

static F53OSCValue *_oscTrue;
static F53OSCValue *_oscFalse;
static F53OSCValue *_oscNull;
static F53OSCValue *_oscImpulse;


@interface F53OSCValue ()

@property (assign)          const char oscTypeTag;

+ (instancetype) valueWithBytes:(const void *)value objCType:(const char *)type;
+ (instancetype) value:(const void *)value withObjCType:(const char *)type;

// redeclare to make available internally for SDKs prior to macOS 10.13, iOS 11.0, and tvOS 11.0
- (void) getValue:(void *)value size:(NSUInteger)size;

@end


@implementation F53OSCValue

+ (instancetype) oscTrue
{
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        const char value = 'T';
        _oscTrue = [F53OSCValue valueWithBytes:&value objCType:@encode(char)];
    });
    return _oscTrue;
}

+ (instancetype) oscFalse
{
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        const char value = 'F';
        _oscFalse = [F53OSCValue valueWithBytes:&value objCType:@encode(char)];
    });
    return _oscFalse;
}

+ (instancetype) oscNull
{
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        const char value = 'N';
        _oscNull = [F53OSCValue valueWithBytes:&value objCType:@encode(char)];
    });
    return _oscNull;
}

+ (instancetype) oscImpulse
{
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        const char value = 'I';
        _oscImpulse = [F53OSCValue valueWithBytes:&value objCType:@encode(char)];
    });
    return _oscImpulse;
}

#pragma mark - subclassing

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wobjc-designated-initializers"
- (instancetype) initWithBytes:(const void *)value objCType:(const char *)type
{
    // NOTE: NSValue subclasses must call `[super init]`, even though it is not the designated initializer.
    // - so it is safe to suppress the compiler warning generated by calling `init`
    self = [super init];
    if ( self )
    {
        char *charType = @encode(char);
        if ( *type == *charType )
            self.oscTypeTag = *(char *)value;
        else
            [[NSException exceptionWithName:@"Invalid parameter"
                                     reason:[NSString stringWithFormat:@"F53OSCValue: objCType type '%s' is unsupported, must be char type 'c'", type]
                                   userInfo:nil] raise];
    }
    return self;
}
#pragma clang diagnostic pop

+ (instancetype) valueWithBytes:(const void *)value objCType:(const char *)type
{
    return [[F53OSCValue alloc] initWithBytes:value objCType:type];
}

+ (instancetype) value:(const void *)value withObjCType:(const char *)type
{
    return [F53OSCValue valueWithBytes:value objCType:type];
}

- (void) getValue:(void *)value size:(NSUInteger)size
{
    if ( value != NULL )
    {
        if ( size < sizeof(char) )
            return;
        
        *(char *)value = self.oscTypeTag;
    }
}

- (void) getValue:(void *)value
{
    [self getValue:value size:sizeof(char)];
}

- (const char *) objCType
{
    return @encode(char);
}

- (NSUInteger) hash
{
    return (NSUInteger)self.oscTypeTag;
}

#pragma mark - NSCopying

- (id) copyWithZone:(nullable NSZone *)zone
{
    F53OSCValue *copy = [F53OSCValue allocWithZone:zone];
    copy.oscTypeTag = self.oscTypeTag;
    return copy;
}

#pragma mark - NSSecureCoding

+ (BOOL) supportsSecureCoding
{
    return YES;
}

- (void) encodeWithCoder:(NSCoder *)aCoder
{
    [super encodeWithCoder:aCoder];
    
    [aCoder encodeInt:self.oscTypeTag forKey:@"oscTypeTag"];
}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wobjc-designated-initializers"
- (nullable instancetype) initWithCoder:(NSCoder *)aDecoder
{
    // See the note above in initWithBytes:objCType: about NSValue and its designated initializers
    self = [super init];
    if ( self )
    {
        int oscTypeTag = [aDecoder decodeIntForKey:@"oscTypeTag"];
        if ( oscTypeTag <= CHAR_MAX )
            self.oscTypeTag = (char)oscTypeTag;
        else
            [[NSException exceptionWithName:@"Invalid value"
                                     reason:[NSString stringWithFormat:@"F53OSCValue: value decoded for key \"oscTypeTag\" is too large, must be type char: %d", oscTypeTag]
                                   userInfo:nil] raise];
    }
    return self;
}
#pragma clang diagnostic pop

- (Class) classForCoder
{
    return [F53OSCValue class];
}

- (nullable Class) classForKeyedArchiver
{
    return [F53OSCValue class];
}

#pragma mark - custom

- (BOOL) boolValue
{
    // OSC False, OSC Null, or a zero-value
    if ( self.oscTypeTag == 'F' || self.oscTypeTag == 'N' || self.oscTypeTag == '0' || self.oscTypeTag == 0 )
        return NO;
    
    // OSC True, OSC Impulse, or any non-zero value
    else
        return YES;
}

@end

NS_ASSUME_NONNULL_END
